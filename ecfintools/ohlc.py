"""Set of functions and classes used to handle data with Open, High, Low, Close and Volume"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs-dev/01_ohlcv.ipynb.

# %% auto 0
__all__ = ['candlestick_plot']

# %% ../nbs-dev/01_ohlcv.ipynb 4
from datetime import datetime
from pathlib import Path
from typing import Optional

import pandas as pd
from bokeh.plotting import figure, output_notebook, show

# %% ../nbs-dev/01_ohlcv.ipynb 6
def candlestick_plot(
    df:pd.DataFrame,      # df with datetime index, and at least following columns 'Open', 'High', 'Low', 'Close', 'Volume'
    width:int = 950,      # height of the plot figure
    height:int = 600,     # height of the plot figure
    chart_title:str = '', # title of the chart
    fig:Optional[figure] = None # figure to allow superposition of other lines on candlestick plot
    )-> None:      
    """Create a Bokeh candlestick chart using a dataframe with 'Open', 'High', 'Low', 'Close', 'Volume'."""

    if fig is None:
        p = figure(width=width, height=height, title=chart_title, x_axis_type="datetime")
    else:
        p = fig
    p.xaxis.major_label_orientation = 3.1415 / 4
    p.grid.grid_line_alpha = 0.5

    # x_axis_type as 'datetime' means that the width dimensions are measured in milliseconds
    # note: sometimes, the two first bars are not contiguous (e.g. bar[0]=Fri and bar[1]=Mon)
    # in such case, if interval(bar[1],bar[0]) > interval(contiguous bars).
    # instead of taking the first interval, we take the min interval across the full index
    intervals = df.index.unique().to_series() - df.index.unique().to_series().shift(1)
    interval_in_ms = intervals[1:-1].min().total_seconds() * 1000
    ratio = 0.60

    inc = df['Close'] > df['Open']
    dec = df['Close'] < df['Open']
    flat = df['Close'] == df['Open']

    p.segment(df[inc].index, df.loc[inc, 'High'], df[inc].index, df.loc[inc, 'Low'], color='darkgreen')
    p.segment(df[dec].index, df.loc[dec, 'High'], df[dec].index, df.loc[dec, 'Low'], color='darkred')
    p.segment(df[flat].index, df.loc[flat, 'High'], df[flat].index, df.loc[flat, 'Low'], color='black')

    p.vbar(x=df[inc].index,
           bottom=df.loc[inc, 'Open'],
           top=df.loc[inc, 'Close'],
           width=ratio * interval_in_ms,
           fill_color="darkgreen",
           line_color="darkgreen")
    p.vbar(x=df[dec].index,
           bottom=df.loc[dec, 'Close'],
           top=df.loc[dec, 'Open'],
           width=ratio * interval_in_ms,
           fill_color="darkred",
           line_color="darkred")
    p.vbar(x=df[flat].index,
           bottom=df.loc[flat, 'Close'],
           top=df.loc[flat, 'Open'],
           width=ratio * interval_in_ms,
           fill_color="black",
           line_color="black")

    if fig is None:
        show(p)

